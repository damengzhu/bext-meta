{"type":"javascript","name":"记录页面滚动","version":"3","tags":["工具脚本","阅读脚本"],"synopsis":"记录页面滚动容器和位置，下次页面加载完成时恢复","detail":"<p>如果不想在所有页面使用，</p><p>可以通过表单里的黑白名单进行排除。</p><p><br></p><p>每当到达一个新页面时，会有 <span style=\"color: rgb(206, 145, 120);\">开始记录滚动 </span>的提示。</p><p>用户需要滚动页面，脚本才能捕获到滚动容器并记录滚动位置。</p><p>此后访问相同页面时，会在匹配以下所有条件时，自动滚动到之前的位置 :</p><p><br></p><ol><li>容器的位置 ( XPath ) 与 记录 一致</li><li>容器的 id 与 记录 一致</li><li>容器的 class 与 记录 一致</li><li>容器的高度超过视口高度</li></ol><p><br></p><p>由于现代网页的复杂程度，此脚本失效会非常多见，已知的失效/不准确原因包括 ：</p><p><br></p><ol><li>如果页面文章加载缓慢 ( 框架载入后 超过 4 秒 )，脚本将不再尝试寻找容器</li><li>此脚本按完整 URL 标识页面，所以不同的 hash <span style=\"color: rgb(102, 185, 102);\">#xxx</span> 或查询串 <span style=\"color: rgb(102, 185, 102);\">?key=xxx</span> 会被当成不同页面</li><li>同  1，所以交互以后才出现的容器无法自动滚动</li><li>由于判断条件，所以由于各种原因导致容器 class 不一致的，脚本会认为不是同一容器，不会自动滚动</li></ol><p><br></p><p>由于上述原因，以及种种不可控原因，这个脚本处于 \"能用就用\" 的状态 T_T</p><p><br></p><p>这个脚本使用了如下第三方组件，感谢开发者们的无私奉献 ！</p><p><br></p><ul><li><a href=\"https://www.npmjs.com/package/simple-xpath-position\" rel=\"noopener noreferrer\" style=\"color: rgb(0, 102, 204);\">simple-xpath-position</a></li><li><a href=\"https://www.npmjs.com/package/get-document\" rel=\"noopener noreferrer\" style=\"color: rgb(0, 102, 204);\">get-document</a></li><li><a href=\"https://underscorejs.org/\" rel=\"noopener noreferrer\" style=\"color: rgb(0, 102, 204);\">underscore</a></li><li><a href=\"https://www.npmjs.com/package/bext-lib\" rel=\"noopener noreferrer\" style=\"color: rgb(0, 102, 204);\">bext-lib</a></li></ul><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">The MIT License (MIT)\n\n  simple-xpath-position\n\tCopyright © 2015 The Annotator project contributors\n  get-document\n\tCopyright (c) 2014 Nathan Rajlich &lt;n@n8.io&gt;\n  underscore\n    Copyright (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters &amp; Editors\n  bext-lib\n    Copyright (c) 2022 ikkz\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the “Software”), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.\n\t\n\n\tTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    THE SOFTWARE.\n</pre><p><br></p>","source":"import { runOnce, runAt, runMatch, runNeed } from '@bext/util';\nimport config from '@bext/config';\nimport { toast } from '@bext/ui';\nimport throttle from 'https://unpkg.com/underscore@1.13.1/modules/throttle.js';\nrunOnce(() => {\n    if (!config.hasOwnProperty('black')) config.black = [];\n    if (!config.hasOwnProperty('white')) config.white = [];\n    runMatch({\n        black: config.black,\n        white: config.white,\n        full: true\n    }).then(() => {\n        (() => {\n            function isDocument(d) {\n                return d && d.nodeType === 9;\n            }\n            function getDocument(node) {\n                if (isDocument(node)) {\n                    return node;\n                } else if (isDocument(node.ownerDocument)) {\n                    return node.ownerDocument;\n\n                } else if (isDocument(node.document)) {\n                    return node.document;\n\n                } else if (node.parentNode) {\n                    return getDocument(node.parentNode);\n                } else if (node.commonAncestorContainer) {\n                    return getDocument(node.commonAncestorContainer);\n                } else if (node.startContainer) {\n                    return getDocument(node.startContainer);\n                } else if (node.anchorNode) {\n                    return getDocument(node.anchorNode);\n                }\n            }\n            class DOMException {\n                constructor(message, name) {\n                    this.message = message;\n                    this.name = name;\n                    this.stack = (new Error()).stack;\n                }\n            }\n            DOMException.prototype = new Error();\n            DOMException.prototype.toString = function () {\n                return `${this.name}: ${this.message}`\n            };\n            const FIRST_ORDERED_NODE_TYPE = 9;\n            const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n            window.sXPath = {};\n            window.sXPath.fromNode = (node, root = null) => {\n                if (node === undefined) {\n                    throw new Error('missing required parameter \"node\"')\n                }\n                root = root || getDocument(node);\n                let path = '/';\n                while (node !== root) {\n                    if (!node) {\n                        let message = 'The supplied node is not contained by the root node.';\n                        let name = 'InvalidNodeTypeError';\n                        throw new DOMException(message, name)\n                    }\n                    path = `/${nodeName(node)}[${nodePosition(node)}]${path}`;\n                    node = node.parentNode;\n                }\n                return path.replace(/\\/$/, '')\n            };\n            window.sXPath.toNode = (path, root, resolver = null) => {\n                if (path === undefined) {\n                    throw new Error('missing required parameter \"path\"')\n                }\n                if (root === undefined) {\n                    throw new Error('missing required parameter \"root\"')\n                }\n                let document = getDocument(root);\n                if (root !== document) path = path.replace(/^\\//, './');\n                let documentElement = document.documentElement;\n                if (resolver === null && documentElement.lookupNamespaceURI) {\n                    let defaultNS = documentElement.lookupNamespaceURI(null) || HTML_NAMESPACE;\n                    resolver = (prefix) => {\n                        let ns = { '_default_': defaultNS };\n                        return ns[prefix] || documentElement.lookupNamespaceURI(prefix)\n                    };\n                }\n                return resolve(path, root, resolver)\n            };\n            function nodeName(node) {\n                switch (node.nodeName) {\n                    case '#text': return 'text()'\n                    case '#comment': return 'comment()'\n                    case '#cdata-section': return 'cdata-section()'\n                    default: return node.nodeName.toLowerCase()\n                }\n            }\n            function nodePosition(node) {\n                let name = node.nodeName;\n                let position = 1;\n                while ((node = node.previousSibling)) {\n                    if (node.nodeName === name) position += 1;\n                }\n                return position\n            }\n            function resolve(path, root, resolver) {\n                try {\n                    let nspath = path.replace(/\\/(?!\\.)([^\\/:\\(]+)(?=\\/|$)/g, '/_default_:$1');\n                    return platformResolve(nspath, root, resolver)\n                } catch (err) {\n                    return fallbackResolve(path, root)\n                }\n            }\n            function fallbackResolve(path, root) {\n                let steps = path.split(\"/\");\n                let node = root;\n                while (node) {\n                    let step = steps.shift();\n                    if (step === undefined) break\n                    if (step === '.') continue\n                    let [name, position] = step.split(/[\\[\\]]/);\n                    name = name.replace('_default_:', '');\n                    position = position ? parseInt(position) : 1;\n                    node = findChild(node, name, position);\n                }\n                return node\n            }\n            function platformResolve(path, root, resolver) {\n                let document = getDocument(root);\n                let r = document.evaluate(path, root, resolver, FIRST_ORDERED_NODE_TYPE, null);\n                return r.singleNodeValue\n            }\n            function findChild(node, name, position) {\n                for (node = node.firstChild; node; node = node.nextSibling) {\n                    if (nodeName(node) === name && --position === 0) break\n                }\n                return node\n            }\n\n            let urlChangeFn = null;\n            history.pushState = (f => function pushState() {\n                var ret = f.apply(this, arguments);\n                window.dispatchEvent(new Event('pushstate'));\n                window.dispatchEvent(new Event('urlchange'));\n                return ret;\n            })(history.pushState);\n            history.replaceState = (f => function replaceState() {\n                var ret = f.apply(this, arguments);\n                window.dispatchEvent(new Event('replacestate'));\n                window.dispatchEvent(new Event('urlchange'));\n                return ret;\n            })(history.replaceState);\n            window.addEventListener('popstate', () => {\n                window.dispatchEvent(new Event('urlchange'))\n            });\n            Object.defineProperty(window, 'onurlchange', {\n                get() { return urlChangeFn; },\n                set(fn) {\n                    if (typeof fn === 'function') {\n                        urlChangeFn = fn;\n                        window.addEventListener('urlchange', urlChangeFn);\n                    } else {\n                        window.removeEventListener('urlchange', urlChangeFn);\n                        urlChangeFn = null;\n                    }\n                },\n            })\n        })();\n        runAt('document-end', () => {\n            const stor = window.localStorage,\n                boxkey = 'lemonScrollBox';\n            let boxobj = null, box = null, boxel = null;\n            function getScrollBox(e) {\n                boxel = e.target;\n                let pageid = location.href;\n                if (boxel.scrollTop === undefined) boxel = document.documentElement;\n                try {\n                    box = window.sXPath.fromNode(boxel, document.documentElement);\n                } catch (e) {\n                    box = '.';\n                }\n                if (!boxobj) boxobj = {};\n                boxobj[pageid] =\n                {\n                    box: box,\n                    pos: boxel.scrollTop,\n                    class: boxel.className,\n                    id: boxel.id\n                };\n                stor.setItem(\n                    boxkey,\n                    JSON.stringify(boxobj)\n                );\n            }\n            function startNewRecord() {\n                if (config.toast > 0) toast('开始记录滚动', config.toast);\n                document.addEventListener('scroll', throttle(getScrollBox, 300), true);\n            }\n            function scanPage() {\n                boxobj = JSON.parse(stor.getItem(boxkey));\n                let pageid = location.href;\n                if (boxobj[pageid]) {\n                    runNeed(\n                        () => {\n                            boxel = (boxobj[pageid].box === '') ?\n                                document.documentElement : window.sXPath.toNode(\n                                    boxobj[pageid].box,\n                                    document.documentElement\n                                );\n                            if (boxel &&\n                                boxel.id === boxobj[pageid].id &&\n                                boxel.className === boxobj[pageid].class &&\n                                boxel.scrollHeight > window.innerHeight) {\n                                return true;\n                            } else return false;\n                        },\n                        () => {\n                            setTimeout(() => {\n                                boxel.scrollTop = boxobj[pageid].pos;\n                            }, config.out);\n                        }\n                    );\n                    document.addEventListener('scroll', throttle(getScrollBox, 300), true);\n                } else startNewRecord();\n            }\n            if (stor.hasOwnProperty(boxkey)) {\n                window.onurlchange = scanPage;\n                window.onhashchange = scanPage;\n                scanPage();\n            } else {\n                startNewRecord();\n            }\n        });\n    });\n});","configSchema":{"type":"object","properties":{"black":{"type":"array","items":{"type":"string","title":"关键字","description":"会在 URL 中搜索关键字匹配，不支持通配符"},"title":"域名黑名单"},"white":{"type":"array","items":{"type":"string","description":"会在 URL 中搜索关键字匹配，不支持通配符","title":"关键字"},"title":"域名白名单"},"toast":{"type":"number","title":"提示显示时间","description":"不想提示请设置 0","minimum":0},"out":{"type":"number","title":"延时","description":"有些页面文章加载需要时间"}},"title":"默认设置","required":["out","toast"]},"defaultConfig":{"toast":0.7,"out":600}}